package main

/*
#cgo LDFLAGS: -lX11
#include <X11/Xlib.h>
#include <stdlib.h>
*/
import "C"
import (
	"fmt"
	"unsafe"
)

type Color struct {
	R, G, B float64
}

var (
	ColorBlue    = Color{R: 0.3, G: 0.6, B: 1.0}
	ColorGreen   = Color{R: 0.3, G: 1.0, B: 0.3}
	ColorMagenta = Color{R: 1.0, G: 0.3, B: 1.0}
	ColorRed     = Color{R: 1.0, G: 0.2, B: 0.2}
	ColorYellow  = Color{R: 1.0, G: 1.0, B: 0.3}
	ColorCyan    = Color{R: 0.3, G: 1.0, B: 1.0}
	ColorPurple  = Color{R: 0.6, G: 0.3, B: 1.0}
)

var (
	display *C.Display
	window  C.Window
	gc      C.GC
	screen  C.int
)

func InitOverlay() error {
	display = C.XOpenDisplay(nil)
	if display == nil {
		return fmt.Errorf("cannot open X display")
	}

	screen = C.XDefaultScreen(display)
	rootWindow := C.XRootWindow(display, screen)

	screenWidth := C.XDisplayWidth(display, screen)
	screenHeight := C.XDisplayHeight(display, screen)

	var attrs C.XSetWindowAttributes
	attrs.override_redirect = C.True

	colormap := C.XDefaultColormap(display, screen)
	attrs.colormap = colormap
	attrs.background_pixel = 0
	attrs.border_pixel = 0

	window = C.XCreateWindow(
		display,
		rootWindow,
		0, 0,
		C.uint(screenWidth), C.uint(screenHeight),
		0,
		C.CopyFromParent,
		C.InputOutput,
		C.CopyFromParent,
		C.CWOverrideRedirect|C.CWColormap|C.CWBackPixel|C.CWBorderPixel,
		&attrs,
	)

	C.XSelectInput(display, window, C.ExposureMask)

	var hints C.XClassHint
	className := C.CString("vimsane-overlay")
	defer C.free(unsafe.Pointer(className))
	hints.res_name = className
	hints.res_class = className
	C.XSetClassHint(display, window, &hints)

	atomName := C.CString("_NET_WM_WINDOW_TYPE")
	atomValue := C.CString("_NET_WM_WINDOW_TYPE_DOCK")
	defer C.free(unsafe.Pointer(atomName))
	defer C.free(unsafe.Pointer(atomValue))

	wmType := C.XInternAtom(display, atomName, C.False)
	wmTypeDock := C.XInternAtom(display, atomValue, C.False)
	C.XChangeProperty(display, window, wmType, C.XA_ATOM, 32, C.PropModeReplace,
		(*C.uchar)(unsafe.Pointer(&wmTypeDock)), 1)

	stateAtom := C.CString("_NET_WM_STATE")
	defer C.free(unsafe.Pointer(stateAtom))
	wmState := C.XInternAtom(display, stateAtom, C.False)

	aboveAtom := C.CString("_NET_WM_STATE_ABOVE")
	defer C.free(unsafe.Pointer(aboveAtom))
	wmStateAbove := C.XInternAtom(display, aboveAtom, C.False)

	C.XChangeProperty(display, window, wmState, C.XA_ATOM, 32, C.PropModeReplace,
		(*C.uchar)(unsafe.Pointer(&wmStateAbove)), 1)

	C.XMapWindow(display, window)
	C.XFlush(display)

	gc = C.XCreateGC(display, C.Drawable(window), 0, nil)

	return nil
}

func DrawBorder(color Color, width int) {
	if display == nil {
		return
	}

	screenWidth := C.XDisplayWidth(display, screen)
	screenHeight := C.XDisplayHeight(display, screen)

	C.XClearWindow(display, window)

	var xcolor C.XColor
	xcolor.red = C.ushort(color.R * 65535)
	xcolor.green = C.ushort(color.G * 65535)
	xcolor.blue = C.ushort(color.B * 65535)
	xcolor.flags = C.DoRed | C.DoGreen | C.DoBlue

	colormap := C.XDefaultColormap(display, screen)
	C.XAllocColor(display, colormap, &xcolor)
	C.XSetForeground(display, gc, C.ulong(xcolor.pixel))

	w := C.int(width)

	C.XFillRectangle(display, C.Drawable(window), gc, 0, 0, C.uint(screenWidth), C.uint(w))
	C.XFillRectangle(display, C.Drawable(window), gc, 0, 0, C.uint(w), C.uint(screenHeight))
	C.XFillRectangle(display, C.Drawable(window), gc, screenWidth-w, 0, C.uint(w), C.uint(screenHeight))
	C.XFillRectangle(display, C.Drawable(window), gc, 0, screenHeight-w, C.uint(screenWidth), C.uint(w))

	C.XFlush(display)
}

func Cleanup() {
	if display != nil {
		if gc != nil {
			C.XFreeGC(display, gc)
		}
		if window != 0 {
			C.XDestroyWindow(display, window)
		}
		C.XCloseDisplay(display)
	}
}
