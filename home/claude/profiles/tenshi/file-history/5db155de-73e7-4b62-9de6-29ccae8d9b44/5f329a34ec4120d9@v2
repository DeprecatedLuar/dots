package commands

import (
	"net/url"
	"testing"

	parsecurl "github.com/killlowkey/parse-curl"
)

func TestParseCurlBasic(t *testing.T) {
	curlCmd := `curl -X POST https://api.com -H 'Authorization: Bearer token' -d '{"user":"alice"}'`
	result, err := parsecurl.Parse(curlCmd)

	if err != nil {
		t.Fatalf("Failed to parse curl command: %v", err)
	}

	if result.Method != "POST" {
		t.Errorf("Expected method POST, got %s", result.Method)
	}

	if result.URL != "https://api.com" {
		t.Errorf("Expected URL https://api.com, got %s", result.URL)
	}

	if result.Body != `{"user":"alice"}` {
		t.Errorf("Expected body {\"user\":\"alice\"}, got %s", result.Body)
	}

	authHeader := result.Header["Authorization"]
	if authHeader != "Bearer token" {
		t.Errorf("Expected Authorization header 'Bearer token', got '%s'", authHeader)
	}
}

func TestParseCurlWithQueryParams(t *testing.T) {
	curlCmd := `curl 'https://api.com?foo=bar&baz=qux'`
	result, err := parsecurl.Parse(curlCmd)

	if err != nil {
		t.Fatalf("Failed to parse curl command: %v", err)
	}

	// Check if library keeps query params in URL or separates them
	t.Logf("Parsed URL: %s", result.URL)

	// Parse URL to extract query parameters
	parsedURL, err := url.Parse(result.URL)
	if err != nil {
		t.Fatalf("Failed to parse URL: %v", err)
	}

	t.Logf("URL Path: %s", parsedURL.Path)
	t.Logf("Raw Query: %s", parsedURL.RawQuery)

	// Verify we can extract query params
	queryParams := parsedURL.Query()
	if queryParams.Get("foo") != "bar" {
		t.Errorf("Expected foo=bar, got foo=%s", queryParams.Get("foo"))
	}

	if queryParams.Get("baz") != "qux" {
		t.Errorf("Expected baz=qux, got baz=%s", queryParams.Get("baz"))
	}

	// Verify we can get clean base URL
	baseURL := parsedURL.Scheme + "://" + parsedURL.Host + parsedURL.Path
	if baseURL != "https://api.com" && baseURL != "https://api.com/" {
		t.Errorf("Expected base URL https://api.com, got %s", baseURL)
	}
}

func TestParseCurlComplexHeaders(t *testing.T) {
	curlCmd := `curl -X POST https://api.com/users \
		-H 'Content-Type: application/json' \
		-H 'Authorization: Bearer xyz123' \
		-H 'X-Custom-Header: custom-value' \
		-d '{"name":"test","nested":{"key":"value"}}'`

	result, err := parsecurl.Parse(curlCmd)

	if err != nil {
		t.Fatalf("Failed to parse curl command: %v", err)
	}

	// Verify multiple headers
	if result.Header["Content-Type"] != "application/json" {
		t.Errorf("Expected Content-Type application/json, got %s", result.Header["Content-Type"])
	}

	if result.Header["Authorization"] != "Bearer xyz123" {
		t.Errorf("Expected Authorization Bearer xyz123, got %s", result.Header["Authorization"])
	}

	if result.Header["X-Custom-Header"] != "custom-value" {
		t.Errorf("Expected X-Custom-Header custom-value, got %s", result.Header["X-Custom-Header"])
	}

	// Verify nested JSON body
	expectedBody := `{"name":"test","nested":{"key":"value"}}`
	if result.Body != expectedBody {
		t.Errorf("Expected body %s, got %s", expectedBody, result.Body)
	}
}