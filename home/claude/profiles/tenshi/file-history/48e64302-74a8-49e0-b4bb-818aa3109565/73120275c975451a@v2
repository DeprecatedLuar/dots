# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

error() { echo -e "${RED}→ $1${NC}" >&2; exit 1; }
success() { echo -e "${GREEN}→ $1${NC}"; }
warn() { echo -e "${YELLOW}! $1${NC}"; }
info() { echo -e "${BLUE}→ $1${NC}"; }

check_dotfiles_repo() {
    # Create dots repo if doesn't exist
    if [[ ! -d "$DOTFILES" ]]; then
        mkdir -p "$DOTFILES"
        cd "$DOTFILES"
        git init >/dev/null 2>&1
        mkdir -p config home
    elif [[ ! -d "$DOTFILES/.git" ]]; then
        # Directory exists but not a git repo
        cd "$DOTFILES"
        git init >/dev/null 2>&1
        mkdir -p config home
    fi
}

ensure_dotfiles_structure() {
    mkdir -p "$DOTFILES/config"
    mkdir -p "$DOTFILES/home"
}

# (.nvim -> nvim)
strip_dot() {
    local raw_folder_name="$1"
    echo "${raw_folder_name#.}"
}

# Find where a config currently lives in the filesystem
# Returns: "config nvim" or "home .gitconfig" or "none"
find_in_filesystem() {
    local raw_config_name="$1"
    local config_name=$(strip_dot "$raw_config_name")

    # First: Check literal input (highest priority)
    #1 Check literal in ~/.config
    if [[ -e "$HOME/.config/$raw_config_name" ]] || [[ -L "$HOME/.config/$raw_config_name" ]]; then
        echo "config $raw_config_name"
        return
    fi

    #2 Check literal in ~/
    if [[ -e "$HOME/$raw_config_name" ]] || [[ -L "$HOME/$raw_config_name" ]]; then
        echo "home $raw_config_name"
        return
    fi

    # Second: Check variations if literal not found
    #3 Check stripped version in ~/.config (if different from raw)
    if [[ "$raw_config_name" != "$config_name" ]] && ([[ -e "$HOME/.config/$config_name" ]] || [[ -L "$HOME/.config/$config_name" ]]); then
        echo "config $config_name"
        return
    fi

    #4 Check stripped version in ~/ (if different from raw)
    if [[ "$raw_config_name" != "$config_name" ]] && ([[ -e "$HOME/$config_name" ]] || [[ -L "$HOME/$config_name" ]]); then
        echo "home $config_name"
        return
    fi

    #5 Check with dot prepended in ~/.config (if user didn't type dot)
    if [[ "$raw_config_name" == "$config_name" ]] && ([[ -e "$HOME/.config/.$config_name" ]] || [[ -L "$HOME/.config/.$config_name" ]]); then
        echo "config .$config_name"
        return
    fi

    #6 Check with dot prepended in ~/ (if user didn't type dot)
    if [[ "$raw_config_name" == "$config_name" ]] && ([[ -e "$HOME/.$config_name" ]] || [[ -L "$HOME/.$config_name" ]]); then
        echo "home .$config_name"
        return
    fi

    echo "none"
}

# Check if a config exists in dots repo
# Returns: "config nvim" or "home .gitconfig" or "none"
find_in_dotfiles() {
    local name="$1"
    local stripped=$(strip_dot "$name")

    # Check both with and without dots
    if [[ -e "$DOTFILES/config/$stripped" ]]; then
        echo "config $stripped"
        return
    fi

    if [[ -e "$DOTFILES/config/$name" ]]; then
        echo "config $name"
        return
    fi

    if [[ -e "$DOTFILES/home/$name" ]]; then
        echo "home $name"
        return
    fi

    if [[ -e "$DOTFILES/home/$stripped" ]]; then
        echo "home $stripped"
        return
    fi

    echo "none"
}

# Check if updates are available for dots tool itself
# Returns: 0 if updates available, 1 if up to date, 2 if check failed
check_for_updates() {
    local cache_file="$HOME/.cache/dots_update_check"
    local cache_duration=86400  # 24 hours
    local repo_url="https://github.com/DeprecatedLuar/ireallylovemydots"
    local tool_dir="$HOME/.config/ireallylovemydots"

    # Create cache dir if needed
    mkdir -p "$(dirname "$cache_file")" 2>/dev/null

    # Check cache freshness
    if [[ -f "$cache_file" ]]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || stat -f %m "$cache_file" 2>/dev/null || echo 0)))
        if [[ $cache_age -lt $cache_duration ]]; then
            # Return cached result
            [[ "$(cat "$cache_file")" == "updates_available" ]] && return 0 || return 1
        fi
    fi

    # Fetch latest commit hash from GitHub (silent, non-blocking)
    local remote_hash=$(curl -sS --max-time 3 "https://api.github.com/repos/DeprecatedLuar/ireallylovemydots/commits/master" 2>/dev/null | grep -m1 '"sha"' | cut -d'"' -f4 | head -c 7)

    # If fetch failed, return error (silent)
    [[ -z "$remote_hash" ]] && return 2

    # Get local install date/hash (we'll use the dots binary modification time as proxy)
    local local_timestamp=$(stat -c %Y "$tool_dir/bin/dots" 2>/dev/null || stat -f %m "$tool_dir/bin/dots" 2>/dev/null || echo 0)

    # Fetch commit date from GitHub for the latest commit
    local remote_timestamp=$(curl -sS --max-time 3 "https://api.github.com/repos/DeprecatedLuar/ireallylovemydots/commits/master" 2>/dev/null | grep '"date"' | head -1 | cut -d'"' -f4)
    local remote_epoch=$(date -d "$remote_timestamp" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$remote_timestamp" +%s 2>/dev/null || echo 0)

    # Compare timestamps
    if [[ $remote_epoch -gt $local_timestamp ]]; then
        echo "updates_available" > "$cache_file"
        return 0
    else
        echo "up_to_date" > "$cache_file"
        return 1
    fi
}
