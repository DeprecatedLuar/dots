package main

/*
#cgo LDFLAGS: -lX11 -lXext
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/extensions/shape.h>
#include <stdlib.h>
*/
import "C"
import (
	"fmt"
	"unsafe"
)

type Color struct {
	R, G, B float64
}

var (
	ColorBlue    = Color{R: 0.3, G: 0.6, B: 1.0}
	ColorGreen   = Color{R: 0.45, G: 0.91, B: 0.74}
	ColorMagenta = Color{R: 1.0, G: 0.3, B: 1.0}
	ColorRed     = Color{R: 1.0, G: 0.2, B: 0.2}
	ColorYellow  = Color{R: 1.0, G: 1.0, B: 0.3}
	ColorCyan    = Color{R: 0.3, G: 1.0, B: 1.0}
	ColorPurple  = Color{R: 0.6, G: 0.3, B: 1.0}
)

var (
	display *C.Display
	window  C.Window
	gc      C.GC
	screen  C.int
)

func InitOverlay() error {
	display = C.XOpenDisplay(nil)
	if display == nil {
		return fmt.Errorf("cannot open X display")
	}

	screen = C.XDefaultScreen(display)
	rootWindow := C.XRootWindow(display, screen)

	screenWidth := C.XDisplayWidth(display, screen)
	screenHeight := C.XDisplayHeight(display, screen)

	var attrs C.XSetWindowAttributes
	attrs.override_redirect = C.True
	attrs.background_pixel = 0
	attrs.border_pixel = 0

	window = C.XCreateWindow(
		display,
		rootWindow,
		0, 0,
		C.uint(screenWidth), C.uint(screenHeight),
		0,
		C.int(C.CopyFromParent),
		C.uint(C.InputOutput),
		nil,
		C.CWOverrideRedirect|C.CWBackPixel|C.CWBorderPixel,
		&attrs,
	)

	C.XSelectInput(display, window, C.ExposureMask)

	var hints C.XClassHint
	className := C.CString("vimsane-overlay")
	defer C.free(unsafe.Pointer(className))
	hints.res_name = className
	hints.res_class = className
	C.XSetClassHint(display, window, &hints)

	atomName := C.CString("_NET_WM_WINDOW_TYPE")
	atomValue := C.CString("_NET_WM_WINDOW_TYPE_DOCK")
	defer C.free(unsafe.Pointer(atomName))
	defer C.free(unsafe.Pointer(atomValue))

	wmType := C.XInternAtom(display, atomName, C.False)
	wmTypeDock := C.XInternAtom(display, atomValue, C.False)
	C.XChangeProperty(display, window, wmType, C.XA_ATOM, 32, C.PropModeReplace,
		(*C.uchar)(unsafe.Pointer(&wmTypeDock)), 1)

	stateAtom := C.CString("_NET_WM_STATE")
	defer C.free(unsafe.Pointer(stateAtom))
	wmState := C.XInternAtom(display, stateAtom, C.False)

	aboveAtom := C.CString("_NET_WM_STATE_ABOVE")
	defer C.free(unsafe.Pointer(aboveAtom))
	wmStateAbove := C.XInternAtom(display, aboveAtom, C.False)

	C.XChangeProperty(display, window, wmState, C.XA_ATOM, 32, C.PropModeReplace,
		(*C.uchar)(unsafe.Pointer(&wmStateAbove)), 1)

	inputRegionAtom := C.CString("_NET_WM_WINDOW_TYPE_DOCK")
	defer C.free(unsafe.Pointer(inputRegionAtom))

	inputRegion := C.XCreateRegion()
	C.XShapeCombineRegion(display, window, C.ShapeInput, 0, 0, inputRegion, C.ShapeSet)
	C.XDestroyRegion(inputRegion)

	C.XMapWindow(display, window)
	C.XFlush(display)

	gc = C.XCreateGC(display, C.Drawable(window), 0, nil)

	return nil
}

func DrawBorder(color Color, width int) {
	if display == nil {
		return
	}

	screenWidth := C.XDisplayWidth(display, screen)
	screenHeight := C.XDisplayHeight(display, screen)
	w := C.int(width)
	radius := C.int(16)

	pixmap := C.XCreatePixmap(display, C.Drawable(window), C.uint(screenWidth), C.uint(screenHeight), 1)
	pixmapGC := C.XCreateGC(display, C.Drawable(pixmap), 0, nil)

	C.XSetForeground(display, pixmapGC, 0)
	C.XFillRectangle(display, C.Drawable(pixmap), pixmapGC, 0, 0, C.uint(screenWidth), C.uint(screenHeight))

	C.XSetForeground(display, pixmapGC, 1)

	C.XFillRectangle(display, C.Drawable(pixmap), pixmapGC, radius, 0, C.uint(screenWidth-radius*2), C.uint(w))
	C.XFillRectangle(display, C.Drawable(pixmap), pixmapGC, 0, radius, C.uint(w), C.uint(screenHeight-radius*2))
	C.XFillRectangle(display, C.Drawable(pixmap), pixmapGC, screenWidth-w, radius, C.uint(w), C.uint(screenHeight-radius*2))
	C.XFillRectangle(display, C.Drawable(pixmap), pixmapGC, radius, screenHeight-w, C.uint(screenWidth-radius*2), C.uint(w))

	C.XFillArc(display, C.Drawable(pixmap), pixmapGC, 0, 0, C.uint(radius*2), C.uint(radius*2), 90*64, 90*64)
	C.XFillArc(display, C.Drawable(pixmap), pixmapGC, screenWidth-radius*2, 0, C.uint(radius*2), C.uint(radius*2), 0*64, 90*64)
	C.XFillArc(display, C.Drawable(pixmap), pixmapGC, 0, screenHeight-radius*2, C.uint(radius*2), C.uint(radius*2), 180*64, 90*64)
	C.XFillArc(display, C.Drawable(pixmap), pixmapGC, screenWidth-radius*2, screenHeight-radius*2, C.uint(radius*2), C.uint(radius*2), 270*64, 90*64)

	C.XShapeCombineMask(display, window, C.ShapeBounding, 0, 0, pixmap, C.ShapeSet)

	C.XFreePixmap(display, pixmap)
	C.XFreeGC(display, pixmapGC)

	C.XClearWindow(display, window)

	var xcolor C.XColor
	xcolor.red = C.ushort(color.R * 65535)
	xcolor.green = C.ushort(color.G * 65535)
	xcolor.blue = C.ushort(color.B * 65535)
	xcolor.flags = C.DoRed | C.DoGreen | C.DoBlue

	colormap := C.XDefaultColormap(display, screen)
	C.XAllocColor(display, colormap, &xcolor)
	C.XSetForeground(display, gc, C.ulong(xcolor.pixel))

	C.XFillRectangle(display, C.Drawable(window), gc, radius, 0, C.uint(screenWidth-radius*2), C.uint(w))
	C.XFillRectangle(display, C.Drawable(window), gc, 0, radius, C.uint(w), C.uint(screenHeight-radius*2))
	C.XFillRectangle(display, C.Drawable(window), gc, screenWidth-w, radius, C.uint(w), C.uint(screenHeight-radius*2))
	C.XFillRectangle(display, C.Drawable(window), gc, radius, screenHeight-w, C.uint(screenWidth-radius*2), C.uint(w))

	C.XFillArc(display, C.Drawable(window), gc, 0, 0, C.uint(radius*2), C.uint(radius*2), 90*64, 90*64)
	C.XFillArc(display, C.Drawable(window), gc, screenWidth-radius*2, 0, C.uint(radius*2), C.uint(radius*2), 0*64, 90*64)
	C.XFillArc(display, C.Drawable(window), gc, 0, screenHeight-radius*2, C.uint(radius*2), C.uint(radius*2), 180*64, 90*64)
	C.XFillArc(display, C.Drawable(window), gc, screenWidth-radius*2, screenHeight-radius*2, C.uint(radius*2), C.uint(radius*2), 270*64, 90*64)

	C.XFlush(display)
}

func HideWindow() {
	if display == nil {
		return
	}
	C.XUnmapWindow(display, window)
	C.XFlush(display)
}

func ShowWindow() {
	if display == nil {
		return
	}
	C.XMapWindow(display, window)
	C.XFlush(display)
}

func Cleanup() {
	if display != nil {
		if gc != nil {
			C.XFreeGC(display, gc)
		}
		if window != 0 {
			C.XDestroyWindow(display, window)
		}
		C.XCloseDisplay(display)
	}
}
